<!doctype html>
<!--
spot-mini: Single-file Spotify -> YouTube Music transfer (frontend + backend token exchange)

This file is the frontend. It expects a backend endpoint at /api/exchange_google which exchanges
Google OAuth codes to tokens (server holds CLIENT_SECRET). See the repository notes / assistant
messages for the server function to deploy on Vercel or any host.

Usage:
- Fill CLIENT_ID_SPOTIFY and CLIENT_ID_GOOGLE below.
- Deploy backend (Vercel serverless or Express) and set BACKEND_EXCHANGE to its full URL if different.
- Ensure REDIRECT_URI is registered in both Spotify and Google OAuth settings and matches this page URL.

Security:
- Do not store GOOGLE_CLIENT_SECRET in frontend. Keep it server-side only.

-->
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Spot → YouTube Music (mini)</title>
  <style>
    body{font-family:Inter,system-ui,Segoe UI,Arial;margin:0;background:#0f172a;color:#e6eef8;display:flex;align-items:center;justify-content:center;min-height:100vh}
    .card{width:880px;max-width:95%;background:linear-gradient(180deg,#071029, #071421);padding:24px;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.6)}
    h1{margin:0 0 8px;font-size:20px}
    p{margin:0 0 16px;color:#9fb3d3}
    .row{display:flex;gap:12px;flex-wrap:wrap}
    button{background:#1f6feb;border:none;padding:10px 14px;border-radius:8px;color:white;cursor:pointer}
    select,button,input{font-size:14px}
    .muted{color:#7e9ab5;font-size:13px}
    .col{flex:1;min-width:220px}
    .progress{height:14px;background:#0b1220;border-radius:8px;overflow:hidden;margin-top:10px}
    .bar{height:100%;width:0;background:linear-gradient(90deg,#2dd4bf,#06b6d4)}
    .fail{color:#ffdada;background:#3b1010;padding:8px;border-radius:6px;margin-top:8px}
    .ok{color:#dffdf5;background:#05322b;padding:8px;border-radius:6px;margin-top:8px}
    a.link{color:#7ee7ff;text-decoration:underline}
    footer{margin-top:18px;color:#6f8fb0;font-size:13px}
    textarea{width:100%;height:90px;background:#071421;border:1px solid #12324a;color:#cfeff6;padding:8px;border-radius:6px}
    .small{font-size:12px;color:#9fb3d3}
  </style>
</head>
<body>
  <div class="card">
    <h1>Spot → YouTube Music (mini)</h1>
    <p class="muted">Super minimal. Login to Spotify, pick one playlist, login to Google, then transfer. Tokens live only in your browser session; Google exchange happens via your backend.</p>

    <div class="row">
      <div class="col">
        <div><strong>1) Spotify</strong></div>
        <div style="margin-top:8px">
          <button id="btnSpotifyLogin">Login with Spotify</button>
          <span id="spotifyStatus" class="muted" style="margin-left:12px">Not logged in</span>
        </div>
        <div style="margin-top:12px">
          <label class="muted">Choose playlist</label><br>
          <select id="playlistSelect"><option value="">(login to load)</option></select>
        </div>
      </div>

      <div class="col">
        <div><strong>2) Google / YouTube</strong></div>
        <div style="margin-top:8px">
          <button id="btnGoogleLogin">Login with Google</button>
          <span id="googleStatus" class="muted" style="margin-left:12px">Not logged in</span>
        </div>
        <div style="margin-top:12px">
          <label class="muted">New YouTube playlist name</label><br>
          <input id="ytTitle" placeholder="Copy of My Spotify Playlist" style="width:100%;padding:8px;border-radius:6px;border:1px solid #12324a;background:#071421;color:#dff" />
        </div>
      </div>
    </div>

    <div style="margin-top:16px">
      <button id="btnTransfer">Start Transfer</button>
      <div class="progress" id="progressWrap" style="display:none"><div class="bar" id="progressBar"></div></div>
      <div id="statusBox" style="margin-top:10px"></div>
    </div>

    <div style="margin-top:14px">
      <div><strong>Failures / notes</strong></div>
      <div id="failList" style="margin-top:8px"></div>
    </div>

    <footer>
      <div>Notes: This uses PKCE Authorization Code flows. A small backend is required to exchange the Google code for tokens (so you can keep client_secret server-side). See top of file for setup steps.</div>
    </footer>
  </div>

  <script>
  // --------------------------- CONFIG: fill these ---------------------------
  const CLIENT_ID_SPOTIFY = '21c97a2b42034ed384eb46ca65c7243f';
  const CLIENT_ID_GOOGLE = '103207260568-4pllbrslqs76ef10fref2e0fblsqeff4.apps.googleusercontent.com';
  const REDIRECT_URI = window.location.origin + window.location.pathname; // must match registered redirect exactly
  // Backend exchange endpoint (change if your server uses a different path)
  const BACKEND_EXCHANGE = window.location.origin + '/api/exchange_google';
  // -------------------------------------------------------------------------

  // Spotify & Google endpoints
  const SPOTIFY_AUTHORIZE = 'https://accounts.spotify.com/authorize';
  const SPOTIFY_TOKEN = 'https://accounts.spotify.com/api/token';
  const GOOGLE_AUTHORIZE = 'https://accounts.google.com/o/oauth2/v2/auth';
  const GOOGLE_TOKEN = 'https://oauth2.googleapis.com/token';

  // Scopes
  const SPOTIFY_SCOPES = 'playlist-read-private playlist-read-collaborative';
  const GOOGLE_SCOPES = 'https://www.googleapis.com/auth/youtube';

  // Helpers -----------------------------------------------------------------
  function base64urlencode(str) {
    return btoa(String.fromCharCode.apply(null, new Uint8Array(str)))
      .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
  }

  async function sha256(plain) {
    const encoder = new TextEncoder();
    const data = encoder.encode(plain);
    const hash = await crypto.subtle.digest('SHA-256', data);
    return new Uint8Array(hash);
  }

  function randStr(length=43){
    const arr = new Uint8Array(length);
    crypto.getRandomValues(arr);
    return Array.from(arr).map(n => (n%36).toString(36)).join('');
  }

  async function generatePKCECodes(){
    const verifier = randStr(64);
    const hashed = await sha256(verifier);
    const challenge = base64urlencode(hashed);
    return { verifier, challenge };
  }

  function saveSession(key, val){ sessionStorage.setItem(key, JSON.stringify(val)); }
  function loadSession(key){ const v = sessionStorage.getItem(key); return v ? JSON.parse(v) : null; }

  // UI refs
  const btnSpotifyLogin = document.getElementById('btnSpotifyLogin');
  const btnGoogleLogin = document.getElementById('btnGoogleLogin');
  const playlistSelect = document.getElementById('playlistSelect');
  const spotifyStatus = document.getElementById('spotifyStatus');
  const googleStatus = document.getElementById('googleStatus');
  const btnTransfer = document.getElementById('btnTransfer');
  const ytTitle = document.getElementById('ytTitle');
  const progressWrap = document.getElementById('progressWrap');
  const progressBar = document.getElementById('progressBar');
  const statusBox = document.getElementById('statusBox');
  const failList = document.getElementById('failList');

  // On load: check if redirected back with code
  (async function handleRedirect(){
    const url = new URL(window.location.href);
    const code = url.searchParams.get('code');
    const state = url.searchParams.get('state');
    const stored = loadSession('oauth_state');
    if(code && state && stored && stored[state]){
      const entry = stored[state];
      // state object describes which provider: 'spotify' or 'google'
      if(entry.provider === 'spotify'){
        // exchange code for token
        try{
          const token = await exchangeSpotifyCode(code, entry.code_verifier);
          saveSession('spotify_token', token);
          spotifyStatus.textContent = 'Logged in ✓';
          await loadSpotifyPlaylists();
        }catch(err){
          console.error(err);
          spotifyStatus.textContent = 'Spotify token exchange failed (check console)';
        }
      } else if(entry.provider === 'google'){
        try{
          const token = await exchangeGoogleCode(code, entry.code_verifier);
          saveSession('google_token', token);
          googleStatus.textContent = 'Logged in ✓';
        }catch(err){
          console.error(err);
          googleStatus.textContent = 'Google token exchange failed (check console)';
        }
      }
      // clear query params for cleanliness
      url.searchParams.delete('code');
      url.searchParams.delete('state');
      window.history.replaceState({}, document.title, url.pathname);
    } else {
      // on normal load, if tokens in session show statuses
      const sp = loadSession('spotify_token');
      const gd = loadSession('google_token');
      if(sp) spotifyStatus.textContent = 'Logged in ✓';
      if(gd) googleStatus.textContent = 'Logged in ✓';
      if(sp) loadSpotifyPlaylists();
    }
  })();

  // ---------------- SPOTIFY: authorize & token exchange --------------------
  btnSpotifyLogin.addEventListener('click', async ()=>{
    const { verifier, challenge } = await generatePKCECodes();
    const state = randStr(12);
    const key = { provider: 'spotify', code_verifier: verifier };
    const store = loadSession('oauth_state') || {};
    store[state] = key; saveSession('oauth_state', store);

    const params = new URLSearchParams({
      response_type: 'code',
      client_id: CLIENT_ID_SPOTIFY,
      scope: SPOTIFY_SCOPES,
      redirect_uri: REDIRECT_URI,
      code_challenge_method: 'S256',
      code_challenge: challenge,
      state
    });
    window.location = SPOTIFY_AUTHORIZE + '?' + params.toString();
  });

  async function exchangeSpotifyCode(code, code_verifier){
    const body = new URLSearchParams({
      grant_type: 'authorization_code',
      code, redirect_uri: REDIRECT_URI,
      client_id: CLIENT_ID_SPOTIFY,
      code_verifier
    });
    const res = await fetch(SPOTIFY_TOKEN, { method:'POST', headers:{'Content-Type':'application/x-www-form-urlencoded'}, body });
    if(!res.ok) throw new Error('Spotify token exchange failed: '+await res.text());
    return await res.json();
  }

  async function loadSpotifyPlaylists(){
    const token = loadSession('spotify_token');
    if(!token) return;
    const res = await fetch('https://api.spotify.com/v1/me/playlists?limit=50', { headers: { Authorization: 'Bearer ' + token.access_token } });
    if(!res.ok){ console.error('failed to fetch playlists', await res.text()); return; }
    const data = await res.json();
    playlistSelect.innerHTML = '';
    data.items.forEach(pl => {
      const opt = document.createElement('option');
      opt.value = pl.id; opt.textContent = pl.name + ' ('+pl.tracks.total+' tracks)';
      playlistSelect.appendChild(opt);
    });
  }

  // ---------------- GOOGLE: authorize & token exchange --------------------
  btnGoogleLogin.addEventListener('click', async ()=>{
    const { verifier, challenge } = await generatePKCECodes();
    const state = randStr(12);
    const key = { provider: 'google', code_verifier: verifier };
    const store = loadSession('oauth_state') || {};
    store[state] = key; saveSession('oauth_state', store);

    const params = new URLSearchParams({
      client_id: CLIENT_ID_GOOGLE,
      response_type: 'code',
      scope: GOOGLE_SCOPES,
      redirect_uri: REDIRECT_URI,
      access_type: 'offline',
      include_granted_scopes: 'true',
      state,
      code_challenge: challenge,
      code_challenge_method: 'S256'
    });
    window.location = GOOGLE_AUTHORIZE + '?' + params.toString();
  });

  async function exchangeGoogleCode(code, code_verifier){
    // Call backend exchange endpoint which performs the token exchange with Google using CLIENT_SECRET
    const res = await fetch(BACKEND_EXCHANGE, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ code, code_verifier })
    });
    if(!res.ok){
      const text = await res.text();
      throw new Error('Google token exchange failed: '+text);
    }
    return await res.json();
  }

  // ---------------- Robust transfer: retries, backoff, resume ----------------
  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

  async function addVideoToPlaylistWithRetry(access_token, playlistId, videoId, opts={}) {
    const maxAttempts = opts.maxAttempts || 6;
    const baseDelay = opts.baseDelay || 400; // ms
    const maxDelay = opts.maxDelay || 8000;

    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        const url = 'https://www.googleapis.com/youtube/v3/playlistItems?part=snippet';
        const body = { snippet: { playlistId, resourceId: { kind: 'youtube#video', videoId } } };
        const res = await fetch(url, {
          method: 'POST',
          headers: { Authorization: 'Bearer ' + access_token, 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });

        if (res.ok) {
          return await res.json();
        }

        let errorBody;
        try { errorBody = await res.json(); } catch(e){ errorBody = { raw: await res.text() }; }

        if (res.status === 409 && errorBody?.error?.errors?.[0]?.reason === 'playlistItemDuplicate') {
          console.warn('Video already in playlist (duplicate) - skipping:', videoId);
          return { skippedDuplicate: true };
        }

        const transientStatus = res.status >= 500 || res.status === 429 || (errorBody?.error?.status === 'ABORTED') || (errorBody?.error?.errors?.[0]?.reason === 'SERVICE_UNAVAILABLE');
        if (!transientStatus) {
          console.error('YT add permanent error', res.status, errorBody);
          throw new Error('YT add failed: ' + JSON.stringify(errorBody));
        }

        const jitter = Math.floor(Math.random() * 300);
        const delay = Math.min(baseDelay * Math.pow(2, attempt - 1) + jitter, maxDelay);
        console.warn(`Transient YT error (attempt ${attempt}/${maxAttempts}). Retrying in ${delay}ms`, errorBody);
        await sleep(delay);
        continue;

      } catch (err) {
        if (attempt === maxAttempts) {
          console.error('addVideoToPlaylistWithRetry final error', err);
          throw err;
        }
        const jitter = Math.floor(Math.random() * 300);
        const delay = Math.min(400 * Math.pow(2, attempt - 1) + jitter, 8000);
        console.warn(`Network error adding video (attempt ${attempt}). Retrying in ${delay}ms`, err);
        await sleep(delay);
      }
    }

    throw new Error('Failed to add video after retries: ' + videoId);
  }

  function updateProgressAndSave(done, total, playlistId){
    const pct = Math.round((done/total)*100);
    progressBar.style.width = pct + '%';
    statusBox.innerHTML = `<div class="muted">Transferring... (${done}/${total})</div>`;
    sessionStorage.setItem('transfer_progress', JSON.stringify({ playlistId, done, total, timestamp: Date.now() }));
  }

  // ---------------- TRANSFER LOGIC (improved) ------------------------------
  btnTransfer.addEventListener('click', async ()=>{
    clearStatus();
    const spToken = loadSession('spotify_token');
    const gdToken = loadSession('google_token');
    const plId = playlistSelect.value;
    if(!spToken) return alert('Login to Spotify first');
    if(!plId) return alert('Pick a Spotify playlist');
    if(!gdToken) return alert('Login to Google first');

    try{
      const tracks = await fetchAllSpotifyTracks(plId, spToken.access_token);
      if(!tracks.length) return alert('Playlist empty or could not fetch tracks');
      ytTitle.value = ytTitle.value || 'Copy of '+(playlistSelect.options[playlistSelect.selectedIndex].text || 'Spotify playlist');

      const playlist = await createYouTubePlaylist(gdToken.access_token, ytTitle.value, 'Transferred from Spotify');
      const youtubePlaylistId = playlist.id;
      statusBox.innerHTML = `<div class="ok">Created YouTube playlist — <a class="link" target="_blank" href="https://www.youtube.com/playlist?list=${youtubePlaylistId}">Open playlist</a></div>`;

      progressWrap.style.display = 'block'; progressBar.style.width = '0%';

      let startIndex = 0;
      const persisted = sessionStorage.getItem('transfer_progress');
      if (persisted) {
        try {
          const p = JSON.parse(persisted);
          if (p && p.playlistId === plId && p.total === tracks.length) {
            startIndex = p.done;
            console.info('Resuming transfer from index', startIndex);
          }
        } catch(e){}
      }

      const failures = [];
      const delayBetween = 300; // ms between adds

      for (let i = startIndex; i < tracks.length; i++){
        const t = tracks[i];
        const q = buildQuery(t);
        const vid = await searchYouTubeVideo(gdToken.access_token, q);
        if(vid){
          try{
            await addVideoToPlaylistWithRetry(gdToken.access_token, youtubePlaylistId, vid, { maxAttempts: 6, baseDelay: 400 });
            updateProgressAndSave(i+1, tracks.length, plId);
          }catch(err){
            console.error('Failed to add video after retries', { track: t, err });
            failures.push({ track: t, reason: err.message || 'Add failed' });
            updateProgressAndSave(i+1, tracks.length, plId);
          }
        } else {
          failures.push({ track: t, reason: 'No match' });
          updateProgressAndSave(i+1, tracks.length, plId);
        }
        await sleep(delayBetween);
      }

      sessionStorage.removeItem('transfer_progress');

      if(failures.length){
        failList.innerHTML = '';
        failures.forEach(f=>{
          const d = document.createElement('div'); d.className='fail';
          d.innerHTML = `<strong>${f.track.name}</strong> — ${f.track.artists.join(', ')}<br>${f.reason}`;
          failList.appendChild(d);
        });
        statusBox.innerHTML += `<div class="fail">${failures.length} tracks failed to match or add. You can retry or add them manually.</div>`;
      } else {
        statusBox.innerHTML += `<div class="ok">All tracks transferred (or matched to top results).</div>`;
      }

    }catch(err){
      console.error(err); alert('Transfer failed — check console');
    }
  });

  function clearStatus(){ statusBox.innerHTML=''; failList.innerHTML=''; }

  async function fetchAllSpotifyTracks(playlistId, access_token){
    let items = [];
    let url = `https://api.spotify.com/v1/playlists/${playlistId}/tracks?limit=100`;
    while(url){
      const res = await fetch(url, { headers: { Authorization: 'Bearer ' + access_token } });
      if(!res.ok){ console.error('spotify tracks fetch failed', await res.text()); break; }
      const data = await res.json();
      data.items.forEach(it=>{
        if(it.track && it.track.id){
          items.push({ id: it.track.id, name: it.track.name, artists: it.track.artists.map(a=>a.name), duration_ms: it.track.duration_ms });
        }
      });
      url = data.next;
    }
    return items;
  }

  function buildQuery(track){
    let title = track.name.replace(/\(.*?\)/g,'').replace(/\[.*?\]/g,'').trim();
    const artist = track.artists[0] || '';
    return `${artist} - ${title} official audio`;
  }

  async function createYouTubePlaylist(access_token, title, description){
    const url = 'https://www.googleapis.com/youtube/v3/playlists?part=snippet%2Cstatus';
    const body = { snippet: { title, description }, status: { privacyStatus: 'private' } };
    const res = await fetch(url, { method:'POST', headers:{ Authorization:'Bearer '+access_token, 'Content-Type':'application/json' }, body: JSON.stringify(body) });
    if(!res.ok) throw new Error('YT create playlist failed: '+await res.text());
    return await res.json();
  }

  async function searchYouTubeVideo(access_token, q){
    const url = `https://www.googleapis.com/youtube/v3/search?part=snippet&type=video&maxResults=1&q=${encodeURIComponent(q)}`;
    const res = await fetch(url, { headers: { Authorization: 'Bearer ' + access_token } });
    if(!res.ok){ console.error('YT search failed', await res.text()); return null; }
    const data = await res.json();
    if(data.items && data.items.length) return data.items[0].id.videoId;
    return null;
  }

  async function addVideoToPlaylist(access_token, playlistId, videoId){
    // legacy single attempt add kept for compatibility if needed elsewhere
    const url = 'https://www.googleapis.com/youtube/v3/playlistItems?part=snippet';
    const body = { snippet: { playlistId, resourceId: { kind: 'youtube#video', videoId } } };
    const res = await fetch(url, { method: 'POST', headers:{ Authorization:'Bearer '+access_token, 'Content-Type':'application/json' }, body: JSON.stringify(body) });
    if(!res.ok){ throw new Error('YT add failed: '+await res.text()); }
    return await res.json();
  }

  function updateProgress(done, total){
    const pct = Math.round((done/total)*100);
    progressBar.style.width = pct + '%';
    statusBox.innerHTML = `<div class="muted">Transferring... (${done}/${total})</div>`;
  }

  </script>
</body>
</html>